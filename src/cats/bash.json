{"data":[{"cat":"bash","title":"test_files.sh","content":"\n### test file or directory existance.\n\n#using Ctrl-z to revert to previous contents.\n\n# -e: file existance\n# -d: directory existance\n# -f: file existance and is a regular file\n# -L: file existance and is a symbolic link\n# -r: file existance and is readable\n# -w: file existance and is writable\n# -x: file existance and is executable\n# -s: file existance and is not empty\n# -O: file existance and is owned by the current user\n# -G: file existance and is owned by the current group\n# -N: file existance and has been modified since it was last read\n# -nt: file existance and is newer than another file\n# -ot: file existance and is older than another file\n# -ef: file existance and is a hard link to another file\n\n# code example of -nt option\nif [[ file1 -nt file2 ]]; then\n\techo \"file1 is newer than file2\"\nfi\n\nif [[ -e \u0027a\u0027 ]]; then\n\techo \"file exist\"\nelse\n\techo \"file not exist\"\nfi\n\n# if need use sudo to test existance of a file\nif sudo test -e \u0027a\u0027; then\n\techo \"file exist\"\nelse\n\techo \"file not exist\"\nfi\n\n# if need use sudo to compare the newest of two files\nif sudo test file1 -nt file2; then\n\techo \"file1 is newer than file2\"\nfi\n"},{"cat":"bash","title":"loops.sh","content":"### bash loops for while\n\n# while loop example\ncount\u003d1\nwhile [[ $count -le 5 ]]; do\n\techo \"while loop: $count\"\n\t((count++))\ndone\n\n# for loop example\nfor i in {1..5}; do\n\techo \"for loop: $i\"\ndone\n\n# other loop struct?\n# until loop example\ncount\u003d1\nuntil [[ $count -gt 5 ]]; do\n\techo \"until loop: $count\"\n\t((count++))\ndone\n\n# break and continue\ncount\u003d1\nwhile [[ $count -le 5 ]]; do\n\tif [[ $count -eq 3 ]]; then\n\t\t((count++))\n\t\tcontinue\n\tfi\n\tif [[ $count -eq 5 ]]; then\n\t\tbreak\n\tfi\n\techo \"break and continue: $count\"\n\t((count++))\ndone\n\n# arrays example\n# declare -a arr\narr[0]\u003d\"first\"\narr[1]\u003d\"second\"\narr[2]\u003d\"third\"\n\n# loop over arrays\nfor i in \"${arr[@]}\"; do\n\techo \"array: $i\"\ndone\n\n"},{"cat":"bash","title":"equal.sh","content":"\n\n### test and compare string, number, equal and not equal\n#using Ctrl-z to revert to previous contents.\n# \u003d: equal\n# !\u003d: not equal\n# \u003c: less than\n\nif [[ \u0027a\u0027 \u003d \u0027a\u0027 ]];then\n\techo \"a \u003d a\"\nfi\n\nif [[ \u0027a\u0027 !\u003d \u0027b\u0027 ]];then\n\techo \"a !\u003d b\"\nfi\n\nif [[ \u0027a\u0027 \u003c \u0027b\u0027 ]];then\n\techo \"a \u003c b\"\nfi\n\nif [[ -z \u0027\u0027 ]];then\n\techo \"empty string\"\nfi\n\nif [[ -n \u0027a\u0027 ]];then\n\techo \"not empty string\"\nfi\n\nif [[ 1 -eq 1 ]];then\n\techo \"1 -eq 1\"\nfi\n\nif [[ 1 -ne 2 ]];then\n\techo \"1 -ne 2\"\nfi"},{"cat":"bash","title":"args.sh","content":"\n\n### bash arguments process\n#using Ctrl-z to revert to previous contents.\n\n# $0: script name\n# $1: first argument\n# argument number\necho $#\n# all arguments\necho $@\n# all arguments\necho $*\n# what\u0027s the difference $@ and $*\n# $@: each argument is a quoted string\n# $*: all arguments are a single string\n\n# get first value from $@, and explain the syntax\necho ${@:1:1} # ${array:offset:length}\n\n# the following line is syntax error\nvar\u003d$(eval \"set -- $*\"; echo $1) # eval is a command not a function\n\ninput_string\u003d\"one \u0027two three\u0027 four five\"\n# Use eval to treat the input string as if it were command-line arguments\neval set -- $input_string\n\n# Loop through the arguments and print them\nfor arg in \"$@\"; do\n    echo \"Argument: $arg\"\ndone"},{"cat":"bash","title":"test_commands.sh","content":"\n### test command or application installed.\n#using Ctrl-z to revert to previous contents.\n\n# -v: command or application existance\n# using command is better than using which.\n\nif command -v git \u003e/dev/null 2\u003e\u00261; then\n\techo \"git command exist\"\nfi\n\n# test a systemd service is installed.\nif systemctl list-unit-files | grep -q \u0027sshd.service\u0027; then\n\techo \"sshd.service exist\"\nfi\n\n# test a systemd service is running.\nif systemctl status sshd.service | grep -q \u0027Active: active\u0027; then\n\techo \"sshd.service is running\"\nfi\n\n"},{"cat":"bash","title":"curl.sh","content":"\n### 常见的curl用法\n#using Ctrl-z to revert to previous contents.\n\n# 1. 下载文件\ncurl -O http://www.example.com/file.zip # -O: 保存文件的名字为远程文件的名字\ncurl -L -o xyz.ip file.zip http://www.example.com/file.zip # -L: 跟随重定向 -o: 保存文件的名字为xyz.ip\n\n# 2. 上传文件\ncurl -F \"file\u003d@localfile;filename\u003dremotefile\" http://www.example.com/upload.php # -F: 上传文件，格式是multipart/form-data\n# urlencoded\ncurl -d \"name\u003dabc\u0026password\u003d123\" http://www.example.com/login.php # -d: 上传数据，格式是application/x-www-form-urlencoded\n# multiple -d\ncurl -d \"name\u003dabc\" -d \"password\u003d123\" http://www.example.com/login.php\n# raw body\ncurl -d @data.txt http://www.example.com/login.php # -d: 上传数据，格式是raw body\n# json body\ncurl -d \u0027{\"name\":\"abc\",\"password\":\"123\"}\u0027 http://www.example.com/login.php # -d: 上传数据，格式是json body\n# json content from file as body\ncurl -d @data.json http://www.example.com/login.php # -d: 上传数据，格式是json body\n\n# http header\ncurl -H \"Content-Type: application/json\" http://www.example.com/login.php # -H: 设置http header\n# basica authentication\ncurl -u \"username:password\" http://www.example.com/login.php # -u: 设置basic authentication\n# cookie\ncurl -b \"name\u003dabc;password\u003d123\" http://www.example.com/login.php # -b: 设置cookie\n# referer\ncurl -e \"http://www.example.com\" http://www.example.com/login.php # -e: 设置referer\n# user agent\ncurl -A \"Mozilla/5.0 (Windows NT 6.1; rv:60.0) Gecko/20100101 Firefox/60.0\" http://www.example.com/login.php # -A: 设置user agent\n# proxy\ncurl -x \"http://abc.proxy.com:8080\" http://www.example.com/login.php # -x: 设置proxy\n\n\n"},{"cat":"bash","title":"az.sh","content":"### az azure-cli\n\naz login --service-principal -u \u003capp-id\u003e -p \u003cpassword-or-cert\u003e --tenant \u003ctenant\u003e"},{"cat":"bash","title":"multiplelines.sh","content":"\n### multiple lines string to a variable and interpolate the variables in the multiple lines\n#using Ctrl-z to revert to previous contents.\n\n# 1. use cat \u003c\u003c EOF\n# 2. use cat \u003c\u003c \"EOF\"\n# 3. use cat \u003c\u003c \u0027EOF\u0027\n\nv1\u003d\"line 3\"\nv\u003d$(\n\tcat \u003c\u003cEOF\nline 1\nline 2\n$v1\nEOF\n)\necho $v   # no newlines\necho \"$v\" #with newlines\n\nv\u003d$(\n\tcat \u003c\u003c\"EOF\"\nline 1\nline 2\n$v1\nEOF\n)\necho \"$v\"\n\nv\u003d$(\n\tcat \u003c\u003c\u0027EOF\u0027\nline 1\nline 2\n$v1\nEOF\n)\necho \"$v\""}]}